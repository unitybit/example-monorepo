name: Release (Windows, per-app tag)

on:
  push:
    tags:
      - "myapp-v*"
      - "tools-v*"
  workflow_dispatch:

jobs:
  release:
    runs-on: windows-latest
    env:
      # Defaults (overridden in the mapping step)
      APP_NAME: App
      ENTRYPOINT_MODULE: app
      CPYTHON_SERIES: "3.12"   # choose 3.12 or 3.13

    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Parse tag -> APP and VERSION
        id: parse
        shell: pwsh
        run: |
          $tag = "${env:GITHUB_REF_NAME}"   # e.g. myapp-v1.2.3
          if ($tag -notmatch '^([A-Za-z0-9_\-]+)-v(.+)$') {
            Write-Error "Tag must look like <app>-v<version>, got: $tag"
          }
          "APP=$($Matches[1])"     >> $env:GITHUB_ENV
          "VERSION=$($Matches[2])" >> $env:GITHUB_ENV
          Write-Host "APP=$($Matches[1]) VERSION=$($Matches[2])"

      - name: Map APP -> subdirectory and entrypoint
        id: map
        shell: pwsh
        run: |
          switch ($env:APP) {
            "myapp" {
              "APP_PATH=apps\myapp"       >> $env:GITHUB_ENV
              "ENTRYPOINT_MODULE=myapp"    >> $env:GITHUB_ENV  # python -m myapp
              "APP_NAME=MyApp"             >> $env:GITHUB_ENV
            }
            "tools" {
              "APP_PATH=tools\cli"         >> $env:GITHUB_ENV
              "ENTRYPOINT_MODULE=toolcli"  >> $env:GITHUB_ENV
              "APP_NAME=ToolsCLI"          >> $env:GITHUB_ENV
            }
            default {
              Write-Error "Unknown APP '$($env:APP)'. Add it to the switch map."
            }
          }
          Write-Host "Building $env:APP in $env:APP_PATH with entrypoint $env:ENTRYPOINT_MODULE"

      - name: Setup uv (optional)
        uses: astral-sh/setup-uv@v6
        with:
          enable-cache: true

      - name: Prepare bundle layout
        shell: pwsh
        run: |
          New-Item -ItemType Directory -Force -Path bundle | Out-Null
          New-Item -ItemType Directory -Force -Path (Join-Path 'bundle' $env:APP_NAME) | Out-Null

      - name: Download portable Python (python-build-standalone)
        shell: pwsh
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}   # use Actions' token
        run: |
          $headers = @{
            "Accept" = "application/vnd.github+json"
            "X-GitHub-Api-Version" = "2022-11-28"
            "Authorization" = "Bearer $env:GITHUB_TOKEN"
          }

          function Find-PBSAsset {
            param($series)
            for ($page=1; $page -le 5; $page++) {
              $rels = Invoke-RestMethod -Headers $headers -Uri "https://api.github.com/repos/astral-sh/python-build-standalone/releases?per_page=5&page=$page"
              foreach ($rel in $rels) {
                $zipPattern = if ($series) {
                  "cpython-$([regex]::Escape($series))(\.\d+)?\+\d{8}-x86_64-pc-windows-msvc-shared-.*\.zip$"
                } else {
                  "cpython-3\.\d+(\.\d+)?\+\d{8}-x86_64-pc-windows-msvc-shared-.*\.zip$"
                }
                $asset = $rel.assets | Where-Object { $_.name -match $zipPattern } | Select-Object -First 1
                if ($asset) { return $asset }

                $zstPattern = if ($series) {
                  "cpython-$([regex]::Escape($series))(\.\d+)?\+\d{8}-x86_64-pc-windows-msvc-shared-.*\.tar\.zst$"
                } else {
                  "cpython-3\.\d+(\.\d+)?\+\d{8}-x86_64-pc-windows-msvc-shared-.*\.tar\.zst$"
                }
                $asset = $rel.assets | Where-Object { $_.name -match $zstPattern } | Select-Object -First 1
                if ($asset) { return $asset }
              }
            }
            return $null
          }

          $asset = Find-PBSAsset -series $env:CPYTHON_SERIES
          if (-not $asset) { throw "Could not find a Windows 'msvc-shared' asset in recent PBS releases." }

          $outfile = if ($asset.name -like '*.zip') { 'python-runtime.zip' } else { 'python-runtime.tar.zst' }
          Write-Host "Downloading $($asset.name) -> $outfile"
          Invoke-WebRequest -Uri $asset.browser_download_url -OutFile $outfile

          # Clean any stale runtime folder
          if (Test-Path "bundle\python") { Remove-Item "bundle\python" -Recurse -Force }

          # Extract
          if ($outfile -like "*.zip") {
            Expand-Archive -Path $outfile -DestinationPath bundle
          } else {
            choco install 7zip -y | Out-Null
            & "C:\Program Files\7-Zip\7z.exe" x $outfile -obundle -y | Out-Null   # -> .tar
            $tarFile = Get-ChildItem bundle *.tar | Select-Object -First 1
            & "C:\Program Files\7-Zip\7z.exe" x $tarFile.FullName -obundle -y | Out-Null
            Remove-Item $tarFile.FullName
          }

      - name: Normalize runtime folder to bundle\python
        shell: pwsh
        run: |
          $dest = Join-Path $PWD 'bundle\python'
          $candidates = Get-ChildItem -Directory 'bundle' | Where-Object { $_.Name -ne $env:APP_NAME }
          if (-not $candidates -or $candidates.Count -eq 0) {
            throw "No directories found under bundle after extraction."
          }
          $runtime = $candidates | Where-Object { Test-Path (Join-Path $_.FullName 'python.exe') } | Select-Object -First 1
          if (-not $runtime) { $runtime = $candidates | Select-Object -First 1 }
          $src = $runtime.FullName

          if (Test-Path $dest) {
            if ((Resolve-Path $src).Path -eq (Resolve-Path $dest).Path) {
              Write-Host "Python runtime already at bundle\python, skipping move."
              exit 0
            }
            Remove-Item $dest -Recurse -Force
          }

          if ((Resolve-Path $src).Path -ne (Resolve-Path $dest).Path) {
            Move-Item $src $dest
            Write-Host "Moved runtime: $src -> $dest"
          } else {
            Write-Host "Python runtime already normalized."
          }

      - name: Locate python.exe (export PYTHON_EXE)
        shell: pwsh
        run: |
          $py = Get-ChildItem -Path "bundle" -Filter python.exe -Recurse -File | Select-Object -First 1
          if (-not $py) {
            Write-Host "Bundle contents (debug):"
            Get-ChildItem -Recurse -Depth 3 bundle | ForEach-Object { $_.FullName }
            throw "python.exe not found anywhere under bundle/"
          }
          "PYTHON_EXE=$($py.FullName)" >> $env:GITHUB_ENV
          Write-Host "Using Python: $($py.FullName)"

      - name: Copy app sources from monorepo subdir
        shell: pwsh
        run: |
          Copy-Item -Recurse -Force (Join-Path $env:APP_PATH 'app') (Join-Path (Join-Path 'bundle' $env:APP_NAME) 'app')
          if (Test-Path (Join-Path $env:APP_PATH 'pyproject.toml')) { Copy-Item (Join-Path $env:APP_PATH 'pyproject.toml') (Join-Path 'bundle' $env:APP_NAME) }
          if (Test-Path (Join-Path $env:APP_PATH 'uv.lock'))        { Copy-Item (Join-Path $env:APP_PATH 'uv.lock')        (Join-Path 'bundle' $env:APP_NAME) }
          if (Test-Path (Join-Path $env:APP_PATH 'requirements.txt')){ Copy-Item (Join-Path $env:APP_PATH 'requirements.txt') (Join-Path 'bundle' $env:APP_NAME) }

      - name: Export pinned requirements from uv.lock (if present)
        if: ${{ hashFiles(format('{0}/uv.lock', env.APP_PATH)) != '' }}
        shell: pwsh
        working-directory: ${{ env.APP_PATH }}
        run: |
          uv export --frozen --no-hashes --format requirements-txt > requirements.lock.txt
          Copy-Item 'requirements.lock.txt' (Join-Path (Join-Path $env:GITHUB_WORKSPACE (Join-Path 'bundle' $env:APP_NAME)) 'requirements.lock.txt')

      - name: Install app + deps into the bundled runtime
        shell: pwsh
        working-directory: ${{ env.APP_PATH }}
        run: |
          $PY = "$env:PYTHON_EXE"
          if (-not (Test-Path $PY)) { throw "PYTHON_EXE not found at $PY" }
          & $PY -m pip install --upgrade pip
          if (Test-Path "requirements.lock.txt") {
            & $PY -m pip install -r (Join-Path (Join-Path $env:GITHUB_WORKSPACE (Join-Path 'bundle' $env:APP_NAME)) 'requirements.lock.txt')
            & $PY -m pip install .
          } elseif (Test-Path "pyproject.toml") {
            & $PY -m pip install .
          } elseif (Test-Path "requirements.txt") {
            & $PY -m pip install -r "requirements.txt"
          } else {
            Write-Host "No pyproject.toml / requirements found; skipping dependency install."
          }

      - name: Create launcher + README at top level
        shell: pwsh
        run: |
          # Write run.bat at bundle root; it expects python\python.exe next to it
          $batLines = @(
            '@echo off',
            'setlocal',
            'set DIR=%~dp0',
            '"%DIR%python\python.exe" -m ' + $env:ENTRYPOINT_MODULE + ' %*'
          )
          $batContent = ($batLines -join "`r`n")
          Set-Content -Path (Join-Path 'bundle' 'run.bat') -Value $batContent -Encoding Ascii

          $readmeLines = @(
            "$($env:APP_NAME) $($env:VERSION)",
            '',
            'Double-click `run.bat` to start.',
            'No install. No internet required.'
          )
          $readmeContent = ($readmeLines -join "`r`n")
          Set-Content -Path (Join-Path 'bundle' 'README.txt') -Value $readmeContent -Encoding UTF8

      - name: Package artifact (zip contents of bundle/)
        shell: pwsh
        run: |
          $zip = (Join-Path 'bundle' ("$env:APP_NAME-$env:VERSION-windows.zip"))
          if (Test-Path $zip) { Remove-Item $zip -Force }
          Compress-Archive -Path (Join-Path 'bundle' '*') -DestinationPath $zip
          Write-Host "Created $zip"

      - name: Upload artifact
        uses: actions/upload-artifact@v4
        with:
          name: ${{ env.APP_NAME }}-${{ env.VERSION }}-windows
          path: bundle/${{ env.APP_NAME }}-${{ env.VERSION }}-windows.zip
